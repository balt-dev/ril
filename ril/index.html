<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="The Rust Imaging Library. A performant and high-level image processing crate for Rust."><meta name="keywords" content="rust, rustlang, rust-lang, ril"><title>ril - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../normalize.css"><link rel="stylesheet" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../ayu.css" disabled><link rel="stylesheet" href="../dark.css" disabled><link rel="stylesheet" href="../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../storage.js"></script><script defer src="../crates.js"></script><script defer src="../main.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../ril/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div></a><h2></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../ril/index.html"><div class="logo-container"><img class="rust-logo" src="../rust-logo.svg" alt="logo"></div></a><h2 class="location"><a href="#">Crate ril</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 0.10.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li><li><a href="#types">Type Definitions</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../wheel.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn">Crate <a class="mod" href="#">ril</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/ril/lib.rs.html#1-344">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>The Rust Imaging Library. A performant and high-level image processing crate for Rust.</p>
<p>See benchmarks and more by viewing the <a href="https://github.com/jay3332/ril#ril">README</a>. It should
also be noted that the README is updated more frequently than the documentation.</p>
<p>Similarly, you can see the changelog <a href="https://github.com/jay3332/ril/blob/main/CHANGELOG.md">here</a>.</p>
<h2 id="installation"><a href="#installation">Installation</a></h2>
<p>The MSRV (Minimum Supported Rust Version) of this crate is <strong>v1.61.0</strong>.</p>
<p>Add the following to your <code>Cargo.toml</code> dependencies:</p>
<div class="example-wrap"><pre class="language-toml"><code>ril = { version = &quot;0&quot;, features = [&quot;all&quot;] ]
</code></pre></div><h3 id="installing-from-github"><a href="#installing-from-github">Installing from GitHub</a></h3>
<p>You can also use the unstable but latest version by installing from GitHub:</p>
<div class="example-wrap"><pre class="language-toml"><code>ril = { git = &quot;https://github.com/jay3332/ril&quot;, branch = &quot;main&quot;, features = [&quot;all&quot;] }
</code></pre></div><h3 id="using-cargo-add"><a href="#using-cargo-add">Using <code>cargo add</code></a></h3>
<p>If you have cargo &gt;= 1.62.0, you can use <code>cargo add ril --features=all</code>.</p>
<h3 id="cargo-features"><a href="#cargo-features">Cargo Features</a></h3>
<p>RIL currently depends on a few dependencies for certain features - especially for various image encodings.
By default RIL comes with no encoding dependencies but with the <code>text</code> and <code>resize</code> dependencies, which give you text
and resizing capabilities respectively.</p>
<p>You can use the <code>all</code> feature to enable all features, including encoding features. This enables the widest range of
image format support, but adds a lot of dependencies you may not need.</p>
<p>For every image encoding that requires a dependency, a corresponding feature can be enabled for it:</p>
<div><table><thead><tr><th>Encoding</th><th>Feature</th><th>Dependencies</th><th>Default?</th></tr></thead><tbody>
<tr><td>PNG and APNG</td><td><code>png</code></td><td><code>png</code></td><td>no</td></tr>
<tr><td>JPEG</td><td><code>jpeg</code></td><td><code>jpeg-decoder</code>, <code>jpeg-encoder</code></td><td>no</td></tr>
<tr><td>GIF</td><td><code>gif</code></td><td><code>gif</code></td><td>no</td></tr>
<tr><td>WebP</td><td><code>webp</code></td><td><code>libwebp-sys2</code></td><td>no</td></tr>
</tbody></table>
</div>
<p>Other features:</p>
<div><table><thead><tr><th>Description</th><th>Feature</th><th>Dependencies</th><th>Default?</th></tr></thead><tbody>
<tr><td>Font/Text Rendering</td><td><code>text</code></td><td><code>fontdue</code></td><td>yes</td></tr>
<tr><td>Image Resizing</td><td><code>resize</code></td><td><code>fast_image_resize</code></td><td>yes</td></tr>
<tr><td>Color Quantization (using NeuQuant)</td><td><code>quantize</code></td><td><code>color_quant</code></td><td>yes</td></tr>
<tr><td>Gradients</td><td><code>gradient</code></td><td><code>colorgrad</code></td><td>yes</td></tr>
<tr><td>Enable all features,<br/> including all encoding features</td><td><code>all</code></td><td></td><td>no</td></tr>
</tbody></table>
</div><h4 id="webp-support-limitations"><a href="#webp-support-limitations">WebP Support limitations</a></h4>
<p>WebP support uses <code>libwebp</code>, which is a native library. This means that if you try to use the
<code>webp</code> feature when compiling to a WebAssembly target, it might fail. We plan on making a
pure-Rust port of <code>libwebp</code> in the future.</p>
<p>For ease of use, the <code>all-pure</code> feature is provided, which is the equivalent of <code>all</code> minus the
<code>webp</code> feature.</p>
<h2 id="getting-started"><a href="#getting-started">Getting Started</a></h2>
<p>Import the prelude which brings commonly used types and crucial traits into scope:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ril::prelude::<span class="kw-2">*</span>;</code></pre></div>
<p>Because all errors from this crate are of the same type, ril provides a <code>Result</code> type
which you can use in any function that leverages ril, such as the <code>main</code> function:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>ril::prelude::<span class="kw-2">*</span>;

<span class="kw">fn </span>main() -&gt; ril::Result&lt;()&gt; {
    <span class="comment">// code goes here...

    </span><span class="prelude-val">Ok</span>(())
}</code></pre></div>
<p>Now you can use the <code>?</code> operator on anything that returns a <code>Result</code> for convenience.</p>
<h2 id="brief-guide"><a href="#brief-guide">Brief Guide</a></h2>
<p>A quick guide and overview of ril’s interface.</p>
<h3 id="opening-an-image"><a href="#opening-an-image">Opening an image</a></h3>
<p>The <a href="prelude/struct.Image.html#method.open" title="Image::open"><code>open</code></a> method should suit your needs:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>image = Image::&lt;Rgb&gt;::open(<span class="string">&quot;my_image.png&quot;</span>)<span class="question-mark">?</span>;</code></pre></div>
<p>The sole argument can be anything that implements <a href="https://doc.rust-lang.org/1.66.0/core/convert/trait.AsRef.html" title="AsRef"><code>AsRef&lt;Path&gt;</code></a>, such as
a string or a file.</p>
<p>You might have also noticed that <a href="prelude/struct.Image.html" title="Image"><code>Image</code></a> is generic with one type parameter,
which can be anything that implements <a href="trait.Pixel.html" title="Pixel"><code>Pixel</code></a>. It represents what type of pixel
this image has - in this case, the image has RGB pixels.</p>
<p>Common pixel formats are <a href="struct.Rgb.html" title="Rgb"><code>Rgb</code></a> (colored) and <a href="struct.Rgba.html" title="Rgba"><code>Rgba</code></a> (colored with transparency),
which are found in the prelude. There are also grayscale counterparts, such as <a href="struct.L.html" title="L"><code>L</code></a>.</p>
<h4 id="reading-from-a-byte-stream"><a href="#reading-from-a-byte-stream">Reading from a byte stream</a></h4>
<p>You can also read from raw bytes using [<code>from_bytes</code>][Image::decode_from_bytes]:</p>

<div class="example-wrap ignore"><div class='tooltip'>ⓘ</div><pre class="rust rust-example-rendered"><code><span class="kw">let </span>bytes = <span class="macro">include_bytes!</span>(<span class="string">&quot;image.png&quot;</span>) <span class="kw">as </span><span class="kw-2">&amp;</span>[u8]; <span class="comment">// Replace this with your own image data
</span><span class="kw">let </span>image = Image::&lt;Rgb&gt;::from_bytes(ImageFormat::Png, bytes)<span class="question-mark">?</span>;</code></pre></div>
<p>The first argument is the encoding of the image, and the second is a slice of bytes, or anything
that implements [<code>AsRef&lt;[u8]&gt;</code>].</p>
<p>You can also use <a href="prelude/struct.Image.html#method.from_bytes_inferred" title="Image::from_bytes_inferred"><code>from_bytes_inferred</code></a> to
infer the format from the byte slice without having to explicitly provide an encoding:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>image = Image::&lt;Rgb&gt;::from_bytes_inferred(bytes)<span class="question-mark">?</span>;</code></pre></div>
<h3 id="creating-your-own-image"><a href="#creating-your-own-image">Creating your own image</a></h3>
<p>You can create your own image using the <a href="prelude/struct.Image.html#method.new" title="Image::new"><code>Image::new</code></a> method:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>image = Image::new(<span class="number">256</span>, <span class="number">256</span>, Rgb::new(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>));</code></pre></div>
<p>The above creates a 256x256 RGB image with all pixels set to red.</p>
<p>The first argument is the width of the image, the second is the height, and the third is the
fill color. The pixel type of the image can be inferred from this argument, which is why we
don’t have to specify it explicitly as a type argument - Rust type inference is powerful and
infers this for us.</p>
<h4 id="the-from_fn-method"><a href="#the-from_fn-method">The <code>from_fn</code> method</a></h4>
<p>The <a href="prelude/struct.Image.html#method.from_fn" title="Image::from_fn"><code>from_fn</code></a> method is a shortcut for creating an image from a function:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>image = Image::from_fn(<span class="number">256</span>, <span class="number">256</span>, |x, y| {
    <span class="comment">// Do something, maybe with `x` and `y`, and return a pixel
    </span>Rgb::new(x <span class="kw">as </span>u8, y <span class="kw">as </span>u8, <span class="number">0</span>)
});</code></pre></div>
<p>The above is just an example. You specify the width, height, and the function that
generates the pixels. It should take two parameters - <code>x</code> and <code>y</code>, which specify the position
of the pixel to generate - and return a pixel.</p>
<h3 id="encoding-and-saving-images"><a href="#encoding-and-saving-images">Encoding and saving images</a></h3>
<p>You can encode and save an image to a file with the <a href="prelude/struct.Image.html#method.save" title="Image::save"><code>save</code></a> method:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Here&#39;s the red image from before:
</span><span class="kw">let </span>image = Image::new(<span class="number">256</span>, <span class="number">256</span>, Rgb::new(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>));

image.save(ImageFormat::Png, <span class="string">&quot;output.png&quot;</span>)<span class="question-mark">?</span>;</code></pre></div>
<p>The first argument is the encoding of the image, and the second is the path to the file.</p>
<p>You may have noticed this is a bit repetitive, and that it is possible to infer the encoding
from the file extension. In cases like this, you can use the slightly slower
<a href="prelude/struct.Image.html#method.save_inferred" title="Image::save_inferred"><code>save_inferred</code></a> method:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>image.save_inferred(<span class="string">&quot;output.png&quot;</span>)<span class="question-mark">?</span>;</code></pre></div>
<p>Now, you do not have to explicitly specify the encoding as it is inferred from the output path.</p>
<h4 id="encoding-and-saving-images-to-memory"><a href="#encoding-and-saving-images-to-memory">Encoding and saving images to memory</a></h4>
<p>You can encode images to a memory buffer by using the <a href="prelude/struct.Image.html#method.encode" title="Image::encode"><code>encode</code></a> method:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>out = Vec::new();
image.encode(ImageFormat::Png, <span class="kw-2">&amp;mut </span>out)<span class="question-mark">?</span>;

<span class="comment">// Do something with `out`</span></code></pre></div>
<p>The first argument is the encoding of the image, and the second is the output buffer that must
implement <a href="https://doc.rust-lang.org/1.66.0/std/io/trait.Write.html" title="std::io::Write"><code>Write</code></a>.</p>
<p>There is no filename to infer the encoding from, so in this case you have to explicitly
specify the encoding.</p>
<h3 id="manipulating-images"><a href="#manipulating-images">Manipulating images</a></h3>
<p>Now that you know how to create and save images, let’s look at some of the ways we can modify
them!</p>
<h4 id="inverting-images"><a href="#inverting-images">Inverting images</a></h4>
<p>A common manipulation method would be inverting every pixel in the image. To do this, there are
two methods which you can use:</p>
<ul>
<li><a href="prelude/struct.Image.html#method.invert" title="Image::invert"><code>invert</code></a>: Inverts the image in-place</li>
<li><a href="prelude/struct.Image.html#method.inverted" title="Image::inverted"><code>inverted</code></a>: Consumes the image and returns a new image with the inverted pixels</li>
</ul>
<p>A common pattern you’ll see in this crate is that many methods have an in-place method and a
not-in-place counterpart, in which the former can be useful for method chaining. One usually does
not have any memory or performance benefits than the other.</p>
<p>Anyhow, here’s how you’d invert an image:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>image = Image::new(<span class="number">256</span>, <span class="number">256</span>, Rgb::new(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>));
image.invert();
image.save_inferred(<span class="string">&quot;output.png&quot;</span>)<span class="question-mark">?</span>;</code></pre></div>
<p><code>(255, 0, 0)</code> (red) inverts to <code>(0, 255, 255)</code> (cyan), so that should be the color of the
output image.</p>
<p>We can also use <a href="prelude/struct.Image.html#method.inverted" title="Image::inverted"><code>inverted</code></a> to use method chaining:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>Image::new(<span class="number">256</span>, <span class="number">256</span>, Rgb::new(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>))
    .inverted()
    .save_inferred(<span class="string">&quot;output.png&quot;</span>)<span class="question-mark">?</span>;</code></pre></div>
<p>Seems to be a bit cleaner than the first way, but it really just comes down to preference…
and whether or not you have ownership of the image object - you likely want to stay away from
cloning images for no benefit as it is a very expensive operation.</p>
<p>TODO: finish guide</p>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="mod" href="draw/index.html" title="ril::draw mod">draw</a></div><div class="item-right docblock-short">Encloses most drawing implementations and drawable objects.</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="encode/index.html" title="ril::encode mod">encode</a></div><div class="item-right docblock-short">Houses Encoder, Decoder, and frame iterator traits.</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="encodings/index.html" title="ril::encodings mod">encodings</a></div><div class="item-right docblock-short">Contains encoder and decoder implementations for various image formats.</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="error/index.html" title="ril::error mod">error</a></div><div class="item-right docblock-short">Common error types.</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="gradient/index.html" title="ril::gradient mod">gradient</a></div><div class="item-right docblock-short">Handles rendering and logic of gradients.</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="pixel/index.html" title="ril::pixel mod">pixel</a></div><div class="item-right docblock-short">Encloses pixel-related traits and pixel type implementations.</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="prelude/index.html" title="ril::prelude mod">prelude</a></div><div class="item-right docblock-short">The crate prelude exports. Importing this with a wildcard will import most items from RIL that
can be useful for image processing, along with bringing crucial traits into scope.</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="quantize/index.html" title="ril::quantize mod">quantize</a></div><div class="item-right docblock-short">Quantizes unpaletted pixel data to paletted data by quantizing the colors into a palette.</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="sequence/index.html" title="ril::sequence mod">sequence</a></div><div class="item-right docblock-short">Implements the animated image and image sequence interface.</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="text/index.html" title="ril::text mod">text</a></div><div class="item-right docblock-short">Implements the font/text rasterizing and layout interface.</div></div></div><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.BitPixel.html" title="ril::BitPixel struct">BitPixel</a></div><div class="item-right docblock-short">Represents a single-bit pixel that represents either a pixel that is on or off.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Border.html" title="ril::Border struct">Border</a></div><div class="item-right docblock-short">Represents a shape border.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.ConicGradient.html" title="ril::ConicGradient struct">ConicGradient</a></div><div class="item-right docblock-short">A conic gradient.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Ellipse.html" title="ril::Ellipse struct">Ellipse</a></div><div class="item-right docblock-short">An ellipse, which could be a circle.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Font.html" title="ril::Font struct">Font</a></div><div class="item-right docblock-short">Represents a single font along with its alternatives used to render text.
Currently, this supports TrueType and OpenType fonts.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Frame.html" title="ril::Frame struct">Frame</a></div><div class="item-right docblock-short">Represents a frame in an image sequence. It encloses an <a href="prelude/struct.Image.html" title="Image"><code>Image</code></a> and extra metadata
about the frame.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Image.html" title="ril::Image struct">Image</a></div><div class="item-right docblock-short">A high-level image representation.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.ImageSequence.html" title="ril::ImageSequence struct">ImageSequence</a></div><div class="item-right docblock-short">Represents a sequence of image frames such as an animated image.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.L.html" title="ril::L struct">L</a></div><div class="item-right docblock-short">Represents an L, or luminance pixel that is stored as only one single
number representing how bright, or intense, the pixel is.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Line.html" title="ril::Line struct">Line</a></div><div class="item-right docblock-short">A line.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.LinearGradient.html" title="ril::LinearGradient struct">LinearGradient</a></div><div class="item-right docblock-short">A linear gradient.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.PalettedRgb.html" title="ril::PalettedRgb struct">PalettedRgb</a></div><div class="item-right docblock-short">Represents a paletted pixel, holding an index to a palette of Rgb colors represented as a <code>&amp;'p [Rgb]</code>, where <code>'p</code> is the lifetime of the palette.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.PalettedRgba.html" title="ril::PalettedRgba struct">PalettedRgba</a></div><div class="item-right docblock-short">Represents a paletted pixel, holding an index to a palette of Rgba colors represented as a <code>&amp;'p [Rgba]</code>, where <code>'p</code> is the lifetime of the palette.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Paste.html" title="ril::Paste struct">Paste</a></div><div class="item-right docblock-short">Pastes or overlays an image on top of another image.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Polygon.html" title="ril::Polygon struct">Polygon</a></div><div class="item-right docblock-short">A polygon.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Quantizer.html" title="ril::Quantizer struct">Quantizer</a></div><div class="item-right docblock-short">Configuration options regarding behavior of quantization.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.RadialGradient.html" title="ril::RadialGradient struct">RadialGradient</a></div><div class="item-right docblock-short">A radial gradient.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Rectangle.html" title="ril::Rectangle struct">Rectangle</a></div><div class="item-right docblock-short">A rectangle.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Rgb.html" title="ril::Rgb struct">Rgb</a></div><div class="item-right docblock-short">Represents an RGB pixel.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Rgba.html" title="ril::Rgba struct">Rgba</a></div><div class="item-right docblock-short">Represents an RGBA pixel.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.TextLayout.html" title="ril::TextLayout struct">TextLayout</a></div><div class="item-right docblock-short">Represents a high-level text layout that can layout text segments, maybe with different fonts.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.TextSegment.html" title="ril::TextSegment struct">TextSegment</a></div><div class="item-right docblock-short">Represents a text segment that can be drawn.</div></div></div><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.BorderPosition.html" title="ril::BorderPosition enum">BorderPosition</a></div><div class="item-right docblock-short">Represents whether a border is inset, outset, or if it lays in the center.</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.ColorType.html" title="ril::ColorType enum">ColorType</a></div><div class="item-right docblock-short">Represents an arbitrary color type. Note that this does not store the bit-depth or the type used
to store the value of each channel, although it can specify the number of channels.</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.DisposalMethod.html" title="ril::DisposalMethod enum">DisposalMethod</a></div><div class="item-right docblock-short">The method used to dispose a frame before transitioning to the next frame in an image sequence.</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.Dynamic.html" title="ril::Dynamic enum">Dynamic</a></div><div class="item-right docblock-short">Represents a pixel type that is dynamically resolved.</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.DynamicFrameIterator.html" title="ril::DynamicFrameIterator enum">DynamicFrameIterator</a></div><div class="item-right docblock-short">Represents any one of the different types of frame iterators, compacted into one common enum
with common methods.</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.DynamicSubpixel.html" title="ril::DynamicSubpixel enum">DynamicSubpixel</a></div><div class="item-right docblock-short">Represents a subpixel of a dynamic pixel.</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.Error.html" title="ril::Error enum">Error</a></div><div class="item-right docblock-short">Represents an error that occurs within the crate.</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.GradientBlendMode.html" title="ril::GradientBlendMode enum">GradientBlendMode</a></div><div class="item-right docblock-short">Color blending mode</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.GradientInterpolation.html" title="ril::GradientInterpolation enum">GradientInterpolation</a></div><div class="item-right docblock-short">Interpolation mode</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.GradientPosition.html" title="ril::GradientPosition enum">GradientPosition</a></div><div class="item-right docblock-short">Represents where the center of a radial or conic gradient is placed.</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.HorizontalAnchor.html" title="ril::HorizontalAnchor enum">HorizontalAnchor</a></div><div class="item-right docblock-short">Represents where text is anchored horizontally.</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.ImageFormat.html" title="ril::ImageFormat enum">ImageFormat</a></div><div class="item-right docblock-short">Represents the underlying encoding format of an image.</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.LoopCount.html" title="ril::LoopCount enum">LoopCount</a></div><div class="item-right docblock-short">Determines how many times an image sequence should repeat itself, or if it
should repeat infinitely.</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.OverlayMode.html" title="ril::OverlayMode enum">OverlayMode</a></div><div class="item-right docblock-short">The behavior to use when overlaying images on top of each other.</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.RadialGradientCover.html" title="ril::RadialGradientCover enum">RadialGradientCover</a></div><div class="item-right docblock-short">How a radial gradient should cover its shape if the aspect ratio of the bounding box != 1.</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.ResizeAlgorithm.html" title="ril::ResizeAlgorithm enum">ResizeAlgorithm</a></div><div class="item-right docblock-short">A filtering algorithm that is used to resize an image.</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.VerticalAnchor.html" title="ril::VerticalAnchor enum">VerticalAnchor</a></div><div class="item-right docblock-short">Represents where text is anchored vertically.</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.WrapStyle.html" title="ril::WrapStyle enum">WrapStyle</a></div><div class="item-right docblock-short">Determines how text should be wrapped.</div></div></div><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Alpha.html" title="ril::Alpha trait">Alpha</a></div><div class="item-right docblock-short">Represents a pixel that supports alpha, or transparency values.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Banded.html" title="ril::Banded trait">Banded</a></div><div class="item-right docblock-short">Represents an image with multiple channels, called bands.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Decoder.html" title="ril::Decoder trait">Decoder</a></div><div class="item-right docblock-short">Low-level decoder interface around an image format.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Draw.html" title="ril::Draw trait">Draw</a></div><div class="item-right docblock-short">A common trait for all objects able to be drawn on an image.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Encoder.html" title="ril::Encoder trait">Encoder</a></div><div class="item-right docblock-short">Low-level encoder interface around an image format.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Fill.html" title="ril::Fill trait">Fill</a></div><div class="item-right docblock-short">Handles the actual filling of a shape. See <a href="trait.IntoFill.html" title="IntoFill"><code>IntoFill</code></a> for more information.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.FrameIterator.html" title="ril::FrameIterator trait">FrameIterator</a></div><div class="item-right docblock-short">Represents the lazy decoding of frames from an encoded image sequence, such as an animated
image.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.IntoFill.html" title="ril::IntoFill trait">IntoFill</a></div><div class="item-right docblock-short">Any fill type that can be used to fill a shape, i.e. solid colors or gradients.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Paletted.html" title="ril::Paletted trait">Paletted</a></div><div class="item-right docblock-short">A trait representing a paletted pixel. <a href="trait.Pixel.html#associatedtype.Subpixel" title="Pixel::Subpixel"><code>Pixel::Subpixel</code></a> is the type of the palette index.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Pixel.html" title="ril::Pixel trait">Pixel</a></div><div class="item-right docblock-short">Represents any type of pixel in an image.</div></div><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.TrueColor.html" title="ril::TrueColor trait">TrueColor</a></div><div class="item-right docblock-short">A trait representing all pixels that can be safely represented as either RGB or RGBA true color.</div></div></div><h2 id="types" class="small-section-header"><a href="#types">Type Definitions</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="type" href="type.Result.html" title="ril::Result type">Result</a></div><div class="item-right docblock-short">A shortcut type equivalent to <code>Result&lt;T, ril::Error&gt;</code>.</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../" data-current-crate="ril" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.66.0 (69f9c33d7 2022-12-12)" ></div></body></html>